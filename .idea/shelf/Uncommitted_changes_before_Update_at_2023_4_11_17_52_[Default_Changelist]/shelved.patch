Index: settings.py
===================================================================
diff --git a/settings.py b/settings.py
deleted file mode 100644
--- a/settings.py	(revision e495933717aaaca98523a99bca3c9e86cca55535)
+++ /dev/null	(revision e495933717aaaca98523a99bca3c9e86cca55535)
@@ -1,16 +0,0 @@
-#!/usr/bin/env python3
-#-*- coding:UTF-8 -*-
-
-import configparser
-
-cf = configparser.ConfigParser()
-cf.read(filenames='config.ini')
-
-config = cf.items()
-
-# read account info
-
-reader_user = config['ACCOUNT'].get('read_user')
-
-# write account info
-write_user = config['ACCOUNT'].get('write_user')
\ No newline at end of file
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
new file mode 100644
--- /dev/null	(date 1676861299017)
+++ b/main.py	(date 1676861299017)
@@ -0,0 +1,46 @@
+#!/usr/bin/env python3
+# -*- coding:UTF-8 -*-
+
+import sys
+
+from core.Network_Automatic_Inspect import NetworkHandler
+
+if __name__ == '__main__':
+    # 开启debug，用于分析后台执行记录结果，方便定位问题
+    # 需要debug，请把注释删除即可，自动会生成一份debug.log文件
+    # logging.basicConfig(filename='debug.log', level=logging.DEBUG)
+    # logging.getLogger("netmiko")
+
+    text = """
+    功能列表：
+    1. 连接测试.
+    2. 采集设备配置信息.
+    3. 保存设备配置.
+    4. 下发设备配置(生产环境请谨慎操作).
+    """
+    print(text)
+
+    choice_function = input("请选择: ")
+    if choice_function == '1':
+        # 测试连接性
+        print('^' * 100)
+        NetworkHandler().main_connect_t()
+        print('^' * 100)
+    elif choice_function == '2':
+        # 采集设备配置信息
+        print('^' * 100)
+        NetworkHandler().main_get_config()
+        print('^' * 100)
+    elif choice_function == '3':
+        # 保存设备配置
+        print('^' * 100)
+        NetworkHandler().main_save_config()
+        print('^' * 100)
+    elif choice_function == '4':
+        # 下发设备配置
+        print('^' * 100)
+        NetworkHandler().main_send_config()
+        print('^' * 100)
+    else:
+        print("没有这个功能!")
+        sys.exit(1)
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
new file mode 100644
--- /dev/null	(date 1673112697145)
+++ b/.idea/encodings.xml	(date 1673112697145)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding">
+    <file url="file://$PROJECT_DIR$/代码优化建议.txt" charset="GBK" />
+  </component>
+</project>
\ No newline at end of file
Index: device_type.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/device_type.py b/device_type.py
new file mode 100644
--- /dev/null	(date 1673112697148)
+++ b/device_type.py	(date 1673112697148)
@@ -0,0 +1,11 @@
+#!/usr/bin/env python3
+#-*- coding:UTF-8 -*-
+
+from netmiko.ssh_dispatcher import CLASS_MAPPER_BASE, CLASS_MAPPER
+for k, v in CLASS_MAPPER_BASE.items():
+    vendor = k.split('_', maxsplit=1)[0]
+    print("{} {}".format(vendor, k))
+print("~" * 100)
+for k, v in CLASS_MAPPER.items():
+    vendor = k.rsplit('_', maxsplit=2)[0]
+    print("{} {}".format(vendor, k))
\ No newline at end of file
Index: core/Network_Automatic_Inspect.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/Network_Automatic_Inspect.py b/core/Network_Automatic_Inspect.py
new file mode 100644
--- /dev/null	(date 1680539196211)
+++ b/core/Network_Automatic_Inspect.py	(date 1680539196211)
@@ -0,0 +1,554 @@
+#!/usr/bin/env python3
+# -*- coding:utf-8 -*-
+
+"""
+作者：by singvis
+微信公众号: 点滴技术
+B站：点滴技术
+update： 2020.08.03
+1.优化下打印输出
+2.windows环境格式化文件命令(replace特殊符号)
+
+update:2022.08.24
+1.增加华为conn_timeout参数
+
+update:2022.09.18
+1.更新disconnect()关闭会话
+
+欢迎大家关注，点赞 收藏 分享，3连击.
+"""
+
+import os
+import re
+import threading
+import platform
+
+from pathlib import Path
+from backend import settings
+from datetime import datetime
+from openpyxl.reader.excel import load_workbook
+from multiprocessing.pool import ThreadPool
+from prettytable import PrettyTable
+from netmiko import ConnectHandler
+from netmiko.ssh_exception import (
+    NetMikoTimeoutException,
+    AuthenticationException,
+    SSHException
+)
+from netmiko.fortinet import FortinetSSH
+from netmiko.juniper import JuniperSSH
+
+BASE_DIR = Path(__file__).resolve().parent
+
+RE_HOSTNAME = {
+    'huawei': re.compile(r"(?<=(\<|\[)).*?(?=(\>|\]))", re.IGNORECASE),  # <hostname> or [hostname]
+    'hp_comware': re.compile(r"(?<=(\<|\[)).*(?=(\>|\]))", re.IGNORECASE),  # <hostname> or [hostname]
+    'cisco': re.compile(r".*?(?=(>|#))", re.IGNORECASE),  # hostname> or hostname#
+    'aruba': re.compile(r".*?(?=(>|#))", re.IGNORECASE),  # hostname#
+    'fortinet': re.compile(r".*?(?=#)", re.IGNORECASE),  # hostname#
+    'a10': re.compile(r".*?(?=(>|#))", re.IGNORECASE),  # hostname-Active> or hostname-Active#
+    'paloalto': re.compile(r"(?<=(@)).*?(?=(\(|\>))", re.IGNORECASE),  # admin@hostname(active)>,
+    'juniper': re.compile(r".*?(?=(\-\>))", re.IGNORECASE),  # hostname->
+}
+
+
+class BaseConnection(object):
+    """
+    基类
+    """
+    pass
+
+
+class MyFortinetSSH(FortinetSSH):
+    """
+    重写了FortinetSSH类
+    """
+
+    # 因为通过ftp备份配置，不需要关闭分屏
+    # 多vdom场景下，需要进入global模式，需要有一些权限权限，可以备份多个vdom的配置
+    def disable_paging(self, delay_factor=1, **kwargs):
+        check_command = "get system status | grep Virtual"
+        output = self.send_command_timing(check_command)
+        self.allow_disable_global = True
+        self.vdoms = False
+        self._output_mode = "more"
+
+        if re.search(r"Virtual domain configuration: (multiple|enable)", output):
+            self.vdoms = True
+            vdom_additional_command = "config global"
+            output = self.send_command_timing(vdom_additional_command, delay_factor=2)
+            if "Command fail" in output:
+                self.allow_disable_global = False
+                self.remote_conn.close()
+                self.establish_connection(width=100, height=1000)
+        return output
+
+
+class MyJuniperSSH(JuniperSSH):
+    """重写了JuniperSSH类"""
+
+    # netscreen 不支持""set cli screen-width 511""命令，调整下命令
+    def session_preparation(self):
+        """Prepare the session after the connection has been established."""
+        self.enter_cli_mode()
+
+        self.disable_paging(
+            command="set console page 0", pattern=r"->"
+        )
+        self.set_base_prompt()
+
+
+class NetworkHandler(object):
+    def __init__(self):
+        """初始参数"""
+        self.BaseDir = BASE_DIR.parent  # 主入口文件夹路径
+        self.device_file = self.BaseDir / "templates" / "巡检模板.xlsx"  # 巡检模板文件，文件名固定的
+        self.pool = ThreadPool(50)  # 并发数，可按需修改
+        self.queueLock = threading.Lock()  # 线程锁
+        self.logtime = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")  # 时间
+        self.log = self.log_dir()
+        self.FtpServer = settings.ftp_server
+        self.FtpUser = settings.ftp_user
+        self.FtpPassword = settings.ftp_password
+
+        self.success = []
+        self.fail = []
+
+    def log_dir(self):
+        """创建目录"""
+        try:
+            LOG = self.BaseDir / 'LOG'
+            # 判断当前目录是否有LOG文件夹，不存在则创建
+            if not os.path.exists(LOG):
+                os.makedirs(LOG)
+            return LOG
+
+        except FileNotFoundError:
+            raise "{}".format("LOG文件夹创建失败.")
+
+    def printPretty(self, msg):
+        """打印消息"""
+        # 在并发的场景中，避免在一行打印出多个结果，不方便查看
+        self.queueLock.acquire()  # 加锁
+        print(msg)
+        self.queueLock.release()  # 释放锁
+
+    def printSum(self, msg):
+        """打印结果汇总信息"""
+        total_devices, success, fail = len(self.success + self.fail), len(self.success), len(self.fail)
+        total_time = "{:0.2f}s".format(msg.total_seconds())
+        tb = PrettyTable(['设备总数', '成功', '失败', '总耗时'])
+        tb.add_row([total_devices, success, fail, total_time])
+        print(tb)
+
+    def write_to_file(self, *args, **kwargs):
+        """
+        将结果写入文件，action的序号保持和choice_function对应，方便理解
+        action = 1, 表示连接设备测试的动作
+        action = 2, 表示采集设备配置的动作
+        action = 3, 表示保存设备配置的动作
+        action = 4, 表示下发设备配置的动作
+        """
+        try:
+            if kwargs['action'] == 1:
+                # 连接设备测试的动作,将结果写入文件
+                with open(self.log / f'connect_t_{self.logtime}.log', 'a') as f:
+                    f.write(kwargs['result'])
+                    f.write('\n')
+            elif kwargs['action'] == 2:
+                # 采集设备配置的动作
+                if kwargs['code'] == 1:
+                    # 将异常的结果写入文本
+                    with open(os.path.join(self.log, f'error_{self.logtime}.log'), 'a') as f:
+                        f.write(kwargs['result'])
+                        f.write('\n')
+                else:
+                    # 将正常的结果写入文本
+                    # LOG/2022-01-01_00:00:01/192.168.1.1_Router01/show run.conf
+                    with open(kwargs['path'], 'a') as f:
+                        f.write(kwargs['result'])
+            elif kwargs['action'] == 3:
+                # 保存设备配置的动作
+                if kwargs['code'] == 1:
+                    # 将异常的结果写入文本
+                    with open(os.path.join(self.log, f'error_{self.logtime}.log'), 'a') as f:
+                        f.write(kwargs['result'])
+                        f.write('\n')
+                else:
+                    # 将正常的结果写入文本
+                    # LOG/2022-01-01_00:00:01/192.168.1.1_Router01/show run.conf
+                    with open(kwargs['path'], 'a') as f:
+                        f.write(kwargs['result'])
+            else:
+                # 将其他异常的写入文件
+                with open(os.path.join(self.log, f'error_{self.logtime}.log'), 'a') as f:
+                    f.write(kwargs['result'])
+                    f.write('\n')
+        except Exception as e:
+            self.printPretty(f"action:{kwargs['action']}错误: {e}")
+
+    def load_excel(self):
+        """加载excel文件"""
+        try:
+            wb = load_workbook(self.device_file)
+            return wb
+
+        except FileNotFoundError:
+            raise ("{} 文件不存在.".format(self.device_file))
+
+    def get_devices_info(self, action=0):
+        """获取设备的基本信息"""
+        try:
+            wb = self.load_excel()
+            ws1 = wb[wb.sheetnames[0]]
+
+            n = 0
+            # 参数min_row、max_col限制取值范围
+            # row(行)从id=1开始...
+            # col(列)从id=1开始...
+            for row in ws1.iter_rows(min_row=2, max_col=10):
+                n += 1
+                if str(row[2].value).strip() == '#':
+                    # 跳过注释行
+                    continue
+                info_dict = {
+                    'ip': row[3].value,
+                    'protocol': row[4].value,
+                    'port': row[5].value,
+                    'username': row[6].value,
+                    'password': row[7].value,
+                    'secret': row[8].value,
+                    'device_type': row[9].value,
+                    'cmd_list': self.get_cmd_info(wb[row[9].value]) if row[9].value else '',
+                    'session_log': row[3].value + '.log',
+                    'session_log_record_writes': True
+                }
+
+                yield info_dict
+
+        except Exception as e:
+            output = f"Excel_第{n}行_Error: {e}"
+            self.printPretty(output)
+            self.write_to_file(**{'action': action, 'result': str(output)})
+        else:
+            # 记得最后要关闭workbook
+            wb.close()
+
+    def get_cmd_info(self, cmd_sheet):
+        """获取命令的信息"""
+        cmd_list = []
+        try:
+            for row in cmd_sheet.iter_rows(min_row=2, max_col=2):
+                if str(row[0].value).strip() != "#" and row[1].value:
+                    # 跳过注释行，去掉命令左右空白处
+                    cmd_list.append(row[1].value.strip())
+
+            return cmd_list
+
+        except Exception as e:
+            self.printPretty("get_cmd_info Error: {}".format(e))
+
+    def format_hostname(self, hostname, device_type):
+        """格式化主机名称"""
+        try:
+            for vendor, regex in RE_HOSTNAME.items():
+                if vendor in device_type:
+                    match = re.search(regex, hostname)
+                    if match:
+                        new_hostname = match.group(0)
+                    else:
+                        new_hostname = hostname.split()[0].strip("<>#$()[] ")
+
+        except Exception as e:
+            self.printPretty(e)
+            raise e
+
+        return new_hostname
+
+    def format_cmd(self, cmd):
+        # 格式化命令行
+        # 避免windown环境文件命令不允许特殊符号,按需修改
+        if platform.system().lower() == 'windows':
+            cmd = cmd.replace('|', '_')
+        else:
+            cmd = cmd
+        return cmd
+
+    def connectHandler(self, host, action=None):
+        """定义一个netmiko对象"""
+        try:
+            connect = ''
+
+            # 判断使用ssh协议
+            if host['protocol'].lower().strip() == 'ssh':
+                host['port'] = host['port'] if (host['port'] not in [22, None]) else 22
+                host.pop('protocol'), host.pop('cmd_list')
+
+                if 'huawei' in host['device_type']:
+                    connect = ConnectHandler(**host, conn_timeout=15)
+                elif 'fortinet' in host['device_type']:
+                    # 调用重写的MyFortinetSSH类
+                    connect = MyFortinetSSH(**host)
+                elif 'juniper' in host['device_type']:
+                    # 优化netscreen设备(优化分屏命令)
+                    connect = MyJuniperSSH(**host)
+                else:
+                    connect = ConnectHandler(**host)
+            # 判断使用telnet协议
+            elif host['protocol'].lower().strip() == 'telnet':
+                host['port'] = host['port'] if (host['port'] not in [23, None]) else 23
+                host.pop('protocol'), host.pop('cmd_list')
+                # netmiko里面支持telnet协议，示例：cisco_ios_telnet
+                host['device_type'] = host['device_type'] + '_telnet'
+
+                # fast_cli=False，为了修复telnet login authentication 报错.
+                connect = ConnectHandler(**host, fast_cli=False)
+            else:
+                # 不支持的协议
+                raise ValueError("{}协议格式填写错误!".format(host['protocol']))
+
+            return connect
+
+        # 异常捕获
+        except NetMikoTimeoutException:
+            e = "Failed.....{:<15} 连通性问题!".format(host['ip'])
+            self.printPretty(e)
+            self.fail.append(host['ip'])
+            self.write_to_file(**{'action': action, 'code': 1, 'result': str(e)})
+        except AuthenticationException:
+            e = "Failed.....{:<15} 用户名或密码错误!".format(host['ip'])
+            self.printPretty(e)
+            self.fail.append(host['ip'])
+            self.write_to_file(**{'action': action, 'code': 1, 'result': str(e)})
+        except SSHException:
+            e = "Failed.....{:<15} SSH版本不兼容!".format(host['ip'])
+            self.printPretty(e)
+            self.fail.append(host['ip'])
+            self.write_to_file(**{'action': action, 'code': 1, 'result': str(e)})
+        except Exception as e:
+            e = "Failed.....{:<15} connectHandler Error: {}".format(host['ip'], e)
+            self.printPretty(e)
+            self.fail.append(host['ip'])
+            self.write_to_file(**{'action': action, 'code': 1, 'result': str(e)})
+
+    def _threadpool(self, *args, **kwargs):
+        # hosts是一个生成器，需要for循环进行遍历
+        hosts = self.get_devices_info()
+        for host in hosts:
+            # 多进程并发
+            self.pool.apply_async(
+                func=kwargs["func"],
+                args=(host,)
+            )
+        self.pool.close()
+        self.pool.join()
+
+    def run_t(self, host, action=1):
+        """主要获取设备名称提示符"""
+        conn = self.connectHandler(host, action=action)
+        if conn:
+            try:
+                output = "获取设备的提示符: {}".format(conn.find_prompt())
+
+                self.printPretty(output)
+                self.success.append(host['ip'])  # 追加到成功的列表
+                self.write_to_file(**{'action': action, 'result': output})  # 将结果接入文件
+
+                # 最后一定要关闭会话
+                conn.disconnect()
+
+            except Exception as e:
+                output = f"run_t Failed...{host['ip']} : {e}"
+                self.printPretty(output)
+                self.fail.append(host['ip'])
+                self.write_to_file(**{'action': action, 'result': output})
+            finally:
+                # 退出netmiko session
+                conn.disconnect()
+
+    def run_get_config(self, host, cmds, action=2):
+        """执行命令和保存信息"""
+        self.printPretty('设备...{:.<15}...开始执行'.format(host['ip']))
+
+        # 特权功能标识位
+        enable = True if host['secret'] else False
+
+        conn = self.connectHandler(host, action=action)
+
+        if conn:
+            # 这里要注意下windown文件命名不能有特殊符号，否则会创建失败
+            try:
+                # 获取设备名称并格式化
+                hostname = self.format_hostname(conn.find_prompt(), host['device_type'])
+                dirname = host['ip'] + '_' + hostname  # 192.168.1.1_Router-01
+                dirpath = os.path.join(self.log, self.logtime, dirname)  # LOG/2022-01-01_00:00:01/192.168.1.1_Router01
+                # 递归创建目录
+                os.makedirs(dirpath)
+            except Exception as e:
+                raise Exception("文件夹创建失败!{}".format(e))
+
+            try:
+                if cmds:
+                    for cmd in cmds:
+                        if enable:
+                            # 进入特权模式
+                            if 'cisco' or 'ruijie' in host['device_type']:
+                                # 默认源码只有cisco支持enabel命令，国产的super需要改写
+                                conn.enable()
+                                output = conn.send_command(cmd)
+                                data = {'action': action, 'code': 0, 'result': output,
+                                        'path': os.path.join(dirpath, self.format_cmd(cmd) + '.conf')}
+                                self.write_to_file(**data)
+                            else:
+                                # 留空，拓展其他厂商
+                                pass
+                        else:
+                            output = conn.send_command(cmd)
+                            data = {'action': action, 'code': 0, 'result': output,
+                                    'path': os.path.join(dirpath, self.format_cmd(cmd) + '.conf')}
+                            self.write_to_file(**data)
+                else:
+                    # 适用于ftp/sftp/scp备份
+                    if host['device_type'] == 'fortinet':
+                        # 飞塔防火墙FTP备份
+                        cmd = "execute backup config ftp {}_{}.conf {} {} {}".format(hostname, self.logtime,
+                                                                                     self.FtpServer,
+                                                                                     self.FtpUser, self.FtpPassword)
+                        conn.send_command(cmd, expect_string="to ftp server OK")
+                    elif host['device_type'] == 'cisco_wlc':
+                        # 按需补充
+                        pass
+                    else:
+                        pass
+
+                self.success.append(host['ip'])
+
+            except Exception as e:
+                output = f"run Failed...{host['ip']} : {e}"
+                self.printPretty(output)
+                self.fail.append(host['ip'])
+                self.write_to_file(**{'action': action, 'code': 1, 'result': str(output)})
+
+            finally:
+                # 退出netmiko session
+                conn.disconnect()
+
+    def run_save_config(self, host, action=3):
+        """
+        执行保存网络设备配置
+        """
+        self.printPretty('设备...{:.<15}...开始执行'.format(host['ip']))
+        # 特权功能标识位
+        enable = True if host['secret'] else False
+
+        conn = self.connectHandler(host, action=action)
+
+        if conn:
+            try:
+                # 获取设备名称并格式化
+                hostname = self.format_hostname(conn.find_prompt(), host['device_type'])
+                dirname = host['ip'] + '_' + hostname  # 192.168.1.1_Router-01
+                dirpath = os.path.join(self.log, self.logtime, dirname)  # LOG/2022-01-01_00:00:01/192.168.1.1_Router01
+                # 递归创建目录
+                os.makedirs(dirpath)
+            except Exception as e:
+                raise Exception("文件夹创建失败!{}".format(e))
+
+            try:
+                # 后台会自动进入特权模式，并执行设备保存命令
+                output = conn.save_config()
+                # self.printPretty(f"{host['ip']}_设备的操作记录:\n{output}")
+                self.success.append(host['ip'])
+                data = {
+                    'action': action,
+                    'code': 0,
+                    'result': output,
+                    'path': os.path.join(dirpath, hostname + '.log')
+                }
+                self.write_to_file(**data)
+
+            except Exception as e:
+                output = f"execute save config Failed...{host['ip']} : {e}"
+                self.printPretty(f"报错: {output}")
+                self.fail.append(host['ip'])
+                self.write_to_file(**{'action': action, 'code': 1, 'result': output})
+
+    def run_send_config(self, host=None, action=4):
+        pass
+
+    def main_connect_t(self):
+        """
+        主程序，测试登录设备
+        """
+        # 开始时间
+        start_time = datetime.now()
+        # 调用进程池
+        self._threadpool(func=self.run_t)
+
+        # 结束时间
+        end_time = datetime.now()
+        # 打印结果
+        self.printSum(end_time - start_time)
+
+    def main_get_config(self):
+        """
+        主程序，采集设备配置信息
+        """
+        start_time = datetime.now()
+
+        # hosts 是一个生成器，需要for循环进行遍历
+        hosts = self.get_devices_info()
+        for host in hosts:
+            self.pool.apply_async(self.run_get_config, args=(host, host['cmd_list']))
+        self.pool.close()
+        self.pool.join()
+
+        # 结束时间
+        end_time = datetime.now()
+        # 打印结果
+        self.printSum(end_time - start_time)
+
+    def main_save_config(self):
+        """
+        主程序，保存设备配置
+        """
+        # 开始时间
+        start_time = datetime.now()
+
+        # hosts 是一个生成器，需要for循环进行遍历
+        hosts = self.get_devices_info()
+        for host in hosts:
+            self.pool.apply_async(self.run_save_config, args=(host,))
+        self.pool.close()
+        self.pool.join()
+
+        # 结束时间
+        end_time = datetime.now()
+        # 打印结果
+        self.printSum(end_time - start_time)
+
+    def main_send_config(self):
+        """
+        主程序，保存设备配置
+        """
+        # 开始时间
+        start_time = datetime.now()
+
+        # hosts 是一个生成器，需要for循环进行遍历
+        hosts = self.get_devices_info()
+        for host in hosts:
+            self.pool.apply_async(self.run_send_config, args=(host,))
+        self.pool.close()
+        self.pool.join()
+
+        # 结束时间
+        end_time = datetime.now()
+        # 打印结果
+        self.printSum(end_time - start_time)
+
+
+if __name__ == '__main__':
+    # pass
+    n = NetworkHandler()
+    n.main_connect_t()
+
Index: core/net_logger.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/net_logger.py b/core/net_logger.py
new file mode 100644
--- /dev/null	(date 1676862159287)
+++ b/core/net_logger.py	(date 1676862159287)
@@ -0,0 +1,24 @@
+import logging
+import logging.handlers
+
+'''
+日志模块
+'''
+LOG_FILENAME = 'jd_seckill.log'
+logger = logging.getLogger()
+
+
+def set_logger():
+    logger.setLevel(logging.INFO)
+    formatter = logging.Formatter('%(asctime)s - %(process)d-%(threadName)s - '
+                                  '%(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s')
+    console_handler = logging.StreamHandler()
+    console_handler.setFormatter(formatter)
+    logger.addHandler(console_handler)
+    file_handler = logging.handlers.RotatingFileHandler(
+        LOG_FILENAME, maxBytes=10485760, backupCount=5, encoding="utf-8")
+    file_handler.setFormatter(formatter)
+    logger.addHandler(file_handler)
+
+
+set_logger()
Index: core/generic_netmiko.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/generic_netmiko.py b/core/generic_netmiko.py
new file mode 100644
--- /dev/null	(date 1673112697147)
+++ b/core/generic_netmiko.py	(date 1673112697147)
@@ -0,0 +1,2 @@
+#!/usr/bin/env python3
+#-*- coding:UTF-8 -*-
\ No newline at end of file
Index: core/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/__init__.py b/core/__init__.py
new file mode 100644
--- /dev/null	(date 1673112697147)
+++ b/core/__init__.py	(date 1673112697147)
@@ -0,0 +1,2 @@
+#!/usr/bin/env python3
+#-*- coding:UTF-8 -*-
\ No newline at end of file
Index: extra/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/extra/__init__.py b/extra/__init__.py
new file mode 100644
--- /dev/null	(date 1676861119386)
+++ b/extra/__init__.py	(date 1676861119386)
@@ -0,0 +1,2 @@
+#!/usr/bin/env python3
+#-*- coding:UTF-8 -*-
\ No newline at end of file
Index: extra/huawei/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/extra/huawei/__init__.py b/extra/huawei/__init__.py
new file mode 100644
--- /dev/null	(date 1676861609003)
+++ b/extra/huawei/__init__.py	(date 1676861609003)
@@ -0,0 +1,2 @@
+#!/usr/bin/env python3
+#-*- coding:UTF-8 -*-
\ No newline at end of file
Index: extra/huawei/huawei.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/extra/huawei/huawei.py b/extra/huawei/huawei.py
new file mode 100644
--- /dev/null	(date 1676861528576)
+++ b/extra/huawei/huawei.py	(date 1676861528576)
@@ -0,0 +1,72 @@
+import time
+import re
+from netmiko.huawei.huawei import HuaweiSSH
+from netmiko.ssh_exception import NetmikoAuthenticationException
+from netmiko import log
+
+COMMIT_CMD = 'commit'
+UNCOMMIT_FALG = ['Warning: Uncommitted configurations found']
+
+EXIT_CMD = 'return'
+
+
+class HuaweiZetSSH(HuaweiSSH):
+
+    def commit(self):
+        self.clear_buffer()
+        cmd = f'{COMMIT_CMD}{self.RETURN}'
+        self.write_channel(cmd)
+        output = self.read_until_prompt_or_pattern(pattern=r"\[.*?\]")
+        # Error: Unrecognized command found at '^' position
+        if 'Unrecognized command' in output:
+            raise Exception('This platform does not support commit,or the device is not in the config mode')
+
+        return output
+
+    def send_config_set(self, *args, **kwargs):
+        '''
+        如果自动commit则调用父类方法的时候，不能退出config模式，先调用重写的commit，
+        然后根据用户最早传入的是否离开config模式决定是否离开config模式。
+        如果非自动commit，暂时不离开config模式，根据回显判断是否有输入yes no的提示（询问是否不提交配置），自动输入一个yes
+        :param auto_commit:  布尔 默认false ，是否自动commit
+        :param kwargs:
+        :return: 交互的整段回显
+        '''
+        intend_exit_config_mode = kwargs.get('exit_config_mode', True)
+        # 执行结束后均不离开config模式 通过intend_exit_config_mode来执行
+        kwargs['exit_config_mode'] = False
+        if 'auto_commit' in kwargs:
+            auto_commit = kwargs.get('auto_commit')
+            del kwargs['auto_commit']
+        else:
+            auto_commit = False
+
+        if auto_commit:
+
+            output = super(HuaweiZetSSH, self).send_config_set(*args, **kwargs)
+            output += self.commit()
+            if intend_exit_config_mode:
+                self.exit_config_mode()
+        else:
+            # Warning: Uncommitted configurations found. Are you sure to commit them before exiting? [Y(yes)/N(no)/C(cancel)]
+            output = super(HuaweiZetSSH, self).send_config_set(*args, **kwargs)
+            pattern = r'>|]|\[Y\S+/N\S+\]'
+            if intend_exit_config_mode:
+                self.clear_buffer()
+                self.write_channel(f'{EXIT_CMD}{self.RETURN}')
+                exit_output = self.read_until_prompt_or_pattern(pattern)
+                output += exit_output
+                # 如果提示有未提交的配置，则输入Y不提交配置。其他情况无此提示信息，则代表return执行成功
+                if self._warning_uncommitted(exit_output):
+                    pattern = '>'
+                    self.write_channel('Y\n')
+                    confirm_output = self.read_until_prompt_or_pattern(pattern)
+                    output += confirm_output
+
+        return output
+
+    def _warning_uncommitted(self, output, uncommitted_flags=UNCOMMIT_FALG):
+        for i in uncommitted_flags:
+            if i in output:
+                return True
+        return False
Index: extra/fiberhome/fiberhome_ssh.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/extra/fiberhome/fiberhome_ssh.py b/extra/fiberhome/fiberhome_ssh.py
new file mode 100644
--- /dev/null	(date 1675836967050)
+++ b/extra/fiberhome/fiberhome_ssh.py	(date 1675836967050)
@@ -0,0 +1,175 @@
+import re
+
+from netmiko.cisco_base_connection import CiscoSSHConnection
+from netmiko.ssh_exception import NetmikoTimeoutException
+
+
+class FiberHomeSSH(CiscoSSHConnection):
+
+    def session_preparation(self) -> None:
+        """Prepare the session after the connection has been established."""
+        self.ansi_escape_codes = True
+        self._test_channel_read(pattern=r"#|>")
+        self.set_terminal_width(
+            command="terminal width 511", pattern=r"terminal width 511"
+        )
+        self.disable_paging()
+        self.set_base_prompt()
+
+    def set_base_prompt(self, pri_prompt_terminator=r'#',
+                        alt_prompt_terminator=r'>',
+                        delay_factor=0.1) -> str:
+        return super(FiberHomeSSH, self).set_base_prompt(pri_prompt_terminator=pri_prompt_terminator,
+                                                         alt_prompt_terminator=alt_prompt_terminator,
+                                                         delay_factor=delay_factor)
+
+    def normalize_linefeeds(self, a_string: str) -> str:
+        """Convert '\r\n' or '\r\r\n' to '\n, and remove extra '\r's in the text."""
+        newline = re.compile(r"(\r\r\n\r|\r\r\n|\r\n)")
+        return newline.sub(self.RESPONSE_RETURN, a_string).replace("\r", "\n")
+
+    def send_command(
+            self,
+            command_string,
+            expect_string=None,
+            delay_factor=1,
+            max_loops=500,
+            auto_find_prompt=True,
+            strip_prompt=True,
+            strip_command=True,
+            normalize=True,
+            use_textfsm=False,
+            textfsm_template=None,
+            use_ttp=False,
+            ttp_template=None,
+            use_genie=False,
+            cmd_verify=False,
+    ):
+        """
+        烽火设备部分命令show的时候，回显在前，执行的命令在回显之后显示，顾将cmd_verify置为False
+        """
+        return super(FiberHomeSSH, self).send_command(command_string,
+                                                      expect_string=expect_string,
+                                                      delay_factor=delay_factor,
+                                                      max_loops=max_loops,
+                                                      auto_find_prompt=auto_find_prompt,
+                                                      strip_prompt=strip_prompt,
+                                                      strip_command=strip_command,
+                                                      normalize=normalize,
+                                                      use_textfsm=use_textfsm,
+                                                      textfsm_template=textfsm_template,
+                                                      use_ttp=use_ttp,
+                                                      ttp_template=ttp_template,
+                                                      use_genie=use_genie,
+                                                      cmd_verify=cmd_verify)
+
+    def send_command_timing(
+            self,
+            command_string,
+            delay_factor=1,
+            max_loops=150,
+            strip_prompt=True,
+            strip_command=True,
+            normalize=True,
+            use_textfsm=False,
+            textfsm_template=None,
+            use_ttp=False,
+            ttp_template=None,
+            use_genie=False,
+            cmd_verify=False,
+            cmd_echo=None,
+    ):
+        """
+        烽火设备部分命令show的时候，回显在前，执行的命令在回显之后显示，顾将cmd_verify置为False
+        """
+        return super(FiberHomeSSH, self).send_command_timing(command_string,
+                                                             delay_factor=delay_factor,
+                                                             max_loops=max_loops,
+                                                             strip_prompt=strip_prompt,
+                                                             strip_command=strip_command,
+                                                             normalize=normalize,
+                                                             use_textfsm=use_textfsm,
+                                                             textfsm_template=textfsm_template,
+                                                             use_ttp=use_ttp,
+                                                             ttp_template=ttp_template,
+                                                             use_genie=use_genie,
+                                                             cmd_verify=cmd_verify)
+
+    def check_enable_mode(self, check_string: str = "#") -> bool:
+        """Check if in enable mode. Return boolean."""
+        return super(FiberHomeSSH, self).check_enable_mode(check_string=check_string)
+
+    def enable(
+            self,
+            cmd: str = r"enable",
+            pattern: str = "ssword",
+            enable_pattern=r'#',
+            re_flags: int = re.IGNORECASE,
+    ) -> str:
+        output = ""
+        msg = (
+            "Failed to enter enable mode. Please ensure you pass "
+            "the 'secret' argument to ConnectHandler."
+        )
+
+        # Check if in enable mode
+        # Send "enable" mode command
+        self.write_channel(self.normalize_cmd(cmd))
+        try:
+            # Read the command echo
+            end_data = ""
+            if self.global_cmd_verify is not False:
+                output += self.read_until_pattern(pattern=re.escape(cmd.strip()))
+                end_data = output.split(cmd.strip())[-1]
+
+            # Search for trailing prompt or password pattern
+            if pattern not in output and self.base_prompt not in end_data:
+                output += self.read_until_prompt_or_pattern(
+                    pattern=pattern, re_flags=re_flags
+                )
+            # Send the "secret" in response to password pattern
+            if re.search(pattern, output):
+                self.write_channel(self.normalize_cmd(self.secret))
+                output += self.read_until_prompt()
+
+            # Search for terminating pattern if defined
+            if enable_pattern and not re.search(enable_pattern, output):
+                output += self.read_until_pattern(pattern=enable_pattern)
+            else:
+                if not self.check_enable_mode():
+                    raise ValueError(msg)
+        except NetmikoTimeoutException:
+            raise ValueError(msg)
+        return output
+
+    def exit_enable_mode(self, exit_command: str = "end") -> str:
+        return super(FiberHomeSSH, self).exit_enable_mode(exit_command=exit_command)
+
+    # 目前来看进入config模式 形如config.*)的回显
+    def check_config_mode(self, check_string: str = "config.*)#", pattern: str = "#") -> bool:
+        """
+        Checks if the device is in configuration mode or not.
+        """
+        return super(FiberHomeSSH, self).check_config_mode(check_string=check_string, pattern=pattern)
+
+    def config_mode(
+            self,
+            config_command: str = "configure",
+            pattern: str = "#",
+            re_flags: int = 0,
+    ) -> str:
+        return super(FiberHomeSSH, self).config_mode(
+            config_command=config_command, pattern=pattern, re_flags=re_flags
+        )
+
+    def exit_config_mode(self, exit_config: str = "end", pattern: str = r"#.*|>.*") -> str:
+        """Exit from configuration mode."""
+        return super().exit_config_mode(exit_config=exit_config, pattern=pattern)
+
+    def save_config(self,
+                    cmd="write file",
+                    confirm=True,
+                    confirm_response="y", ) -> str:
+        return super(FiberHomeSSH, self).save_config(cmd=cmd,
+                                                     confirm=confirm,
+                                                     confirm_response=confirm_response)
Index: extra/fiberhome/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/extra/fiberhome/__init__.py b/extra/fiberhome/__init__.py
new file mode 100644
--- /dev/null	(date 1676861634848)
+++ b/extra/fiberhome/__init__.py	(date 1676861634848)
@@ -0,0 +1,5 @@
+from zetops.zetmiko.fiberhome.fiberhome_ssh import FiberHomeSSH
+
+__all__ = [
+    "FiberHomeSSH",
+]
Index: extra/hillstone/hillstone_ssh.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/extra/hillstone/hillstone_ssh.py b/extra/hillstone/hillstone_ssh.py
new file mode 100644
--- /dev/null	(date 1656231600000)
+++ b/extra/hillstone/hillstone_ssh.py	(date 1656231600000)
@@ -0,0 +1,83 @@
+import re
+
+from netmiko.cisco_base_connection import CiscoSSHConnection
+
+
+class HillStoneSSH(CiscoSSHConnection):
+    def session_preparation(self) -> None:
+        """Prepare the session after the connection has been established."""
+        self.ansi_escape_codes = True
+        self._test_channel_read(pattern=r"#")
+        self.set_terminal_width(
+            command="terminal width 511", pattern=r"terminal width 511"
+        )
+        self.disable_paging()
+        self.set_base_prompt()
+    # 山石设备没有目前来看只有一种符号"#" ，没有右括弧">"
+    def set_base_prompt(self, pri_prompt_terminator=r'#',
+                        alt_prompt_terminator=r'#',
+                        delay_factor=0.1) -> str:
+        return super(HillStoneSSH, self).set_base_prompt(pri_prompt_terminator=pri_prompt_terminator,
+                                                         alt_prompt_terminator=alt_prompt_terminator,
+                                                         delay_factor=delay_factor)
+
+    def normalize_linefeeds(self, a_string: str) -> str:
+        """Convert '\r\n' or '\r\r\n' to '\n, and remove extra '\r's in the text."""
+        newline = re.compile(r"(\r\r\n\r|\r\r\n|\r\n)")
+        return newline.sub(self.RESPONSE_RETURN, a_string).replace("\r", "\n")
+
+    def check_enable_mode(self, check_string: str = "") -> bool:
+        """Check if in enable mode. Return boolean."""
+        return True
+
+    def enable(
+            self,
+            cmd: str = "",
+            pattern: str = "",
+            enable_pattern= None,
+            re_flags: int = re.IGNORECASE,
+    ) -> str:
+        """no enable mode."""
+        return ""
+
+    def exit_enable_mode(self, exit_command: str = "") -> str:
+        """no enable (privileged exec) mode."""
+        return ""
+
+    # 目前来看进入config模式 形如config.*)的回显
+    def check_config_mode(self, check_string: str = "config.*)#", pattern: str = "#") -> bool:
+        """
+        Checks if the device is in configuration mode or not.
+        """
+        return super().check_config_mode(check_string=check_string, pattern=pattern)
+
+    def config_mode(
+            self,
+            config_command: str = "configure",
+            pattern: str = "",
+            re_flags: int = 0,
+    ) -> str:
+        return super().config_mode(
+            config_command=config_command, pattern=pattern, re_flags=re_flags
+        )
+
+    def exit_config_mode(self, exit_config: str = "exit", pattern: str = r"#.*") -> str:
+        """Exit from configuration mode."""
+        return super().exit_config_mode(exit_config=exit_config, pattern=pattern)
+
+
+    def save_config(self) -> str:
+        """Saves Config Using save ,inputs y for save confirm,and inputs y for backup confirm"""
+        save_cmd = 'save'
+        self.enable()
+        self.write_channel(save_cmd)
+        self.write_channel(self.RETURN)
+        save_output = self.read_until_prompt_or_pattern(pattern=r"\[y\]/n:")
+        # first confirm
+        self.write_channel('y')
+        confirm_resp_1st = self.read_until_prompt_or_pattern(pattern=r"y/\[n\]:")
+        # second confirm
+        self.write_channel('y')
+        confirm_resp_2nd = self.read_until_prompt_or_pattern(pattern=r"#")
+        output = save_output + confirm_resp_1st + confirm_resp_2nd
+        return output
\ No newline at end of file
Index: extra/hillstone/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/extra/hillstone/__init__.py b/extra/hillstone/__init__.py
new file mode 100644
--- /dev/null	(date 1676861649679)
+++ b/extra/hillstone/__init__.py	(date 1676861649679)
@@ -0,0 +1,5 @@
+from zetops.zetmiko.hillstone.hillstone_ssh import HillStoneSSH
+
+__all__ = [
+    "HillStoneSSH",
+]
Index: units/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/units/__init__.py b/units/__init__.py
new file mode 100644
--- /dev/null	(date 1673112697149)
+++ b/units/__init__.py	(date 1673112697149)
@@ -0,0 +1,2 @@
+#!/usr/bin/env python3
+#-*- coding:UTF-8 -*-
\ No newline at end of file
Index: backend/settings.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/backend/settings.py b/backend/settings.py
new file mode 100644
--- /dev/null	(date 1676895354498)
+++ b/backend/settings.py	(date 1676895354498)
@@ -0,0 +1,44 @@
+#!/usr/bin/env python3
+# -*- coding:UTF-8 -*-
+
+import configparser
+
+from pathlib import Path
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ configparser start config ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+# 当前文件的绝对路径
+BASE_DIR = Path(__file__).resolve().parent
+
+try:
+    cf = configparser.ConfigParser()
+    cf.read(BASE_DIR / 'config.ini')
+
+    config = dict(cf.items())
+    # print(config)
+except ModuleNotFoundError:
+    print("configparser模块没有安装.")
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ configparser start end ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ account start config ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+# read account info
+read_user = config['ACCOUNT'].get('read_user')
+# write account info
+write_user = config['ACCOUNT'].get('write_user')
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ account start end ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ftp start config ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+# FTP Server info
+ftp_server = config['FTP_SERVER'].get('ftp_server')
+ftp_user = config['FTP_SERVER'].get('ftp_user')
+ftp_password = config['FTP_SERVER'].get('ftp_password')
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ftp start end ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+if __name__ == '__main__':
+    pass
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Network_Automatic_Inspect\r\n适用于网络工程师自动化采集设备信息、保存设备配置等等\r\n\r\n---\r\n\r\n\r\n# 1.拥有那些自动化功能\r\n\r\n## 1.1 功能说明\r\n - 实现批量备份设备配置\r\n - 实现批量保存设备配置\r\n - 实现批量输出巡检报告(待开发)\r\n\r\n# 2.如何使用\r\n``
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision e495933717aaaca98523a99bca3c9e86cca55535)
+++ b/README.md	(date 1673112697146)
@@ -3,13 +3,51 @@
 
 ---
 
+# 1.如何设计与开发
+> B站视频讲解
+
+[1# 网络自动化巡检工具-开篇](https://www.bilibili.com/video/BV1GY411g7e6/)
+
+[2# 网络自动化巡检工具(2)-读取excel基本信息](https://www.bilibili.com/video/BV1G94y1m7XL/)
+
+[3# 网络自动化巡检工具(3)-连接网络设备及执行命令](https://www.bilibili.com/video/BV1V94y1m7wX/)
+
+[4# 网络自动化巡检工具(4)-连接测试及采集写入文件](https://www.bilibili.com/video/BV1VS4y1i7ru/)
+
+[5# 网络自动化巡检工具(5)-如何重写Netmiko中的类](https://www.bilibili.com/video/BV11W4y1k7QW/)
+
+[6# 网络自动化巡检工具(6)-格式化输出](https://www.bilibili.com/video/BV1s94y1R7KE/)
+
+
+# 2.有哪些自动化的功能
+
+## 2.1 功能说明
+ - 实现采集网络设备配置
+ 
+    主要通过`netmiko`模块批量采集设备配置信息，并写入文件。
+ - 实现保存设备配置
+    
+    
+ - 实现输出巡检报告(待开发)
+
+# 3.如何使用
+## 3.1 环境准备
+- 安装好python环境
+- 安装必要的第三方模块
+
+    按照如下命令进行安装：
+    
+    `pip install -r requirement.txt`
+    ```python
+    netmiko==3.4.0
+    prettytable==3.3.0
+    openpyxl==3.0.9
+    ```
 
-# 1.拥有那些自动化功能
 
-## 1.1 功能说明
- - 实现批量备份设备配置
- - 实现批量保存设备配置
- - 实现批量输出巡检报告(待开发)
+# 4.交流群
+## 4.1 微信公众号
 
-# 2.如何使用
+## 4.2 微信交流群
+
 ``
\ No newline at end of file
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>config.ini\r\n*.txt\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	(revision e495933717aaaca98523a99bca3c9e86cca55535)
+++ b/.gitignore	(date 1673112697145)
@@ -1,2 +1,4 @@
-config.ini
-*.txt
+backend/config.ini
+.txt
+LOG
+.log
\ No newline at end of file
